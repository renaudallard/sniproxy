name: Release Packages

on:
  release:
    types:
      - published
  workflow_dispatch:
    inputs:
      ref:
        description: "Git ref (branch/tag) to build packages from"
        required: true
        default: master
      release_tag:
        description: "Existing release tag to attach rebuilt assets to"
        required: true

permissions:
  contents: write

env:
  DEBIAN_FRONTEND: noninteractive
  RPMBUILD_TOPDIR: /tmp/rpmbuild

defaults:
  run:
    shell: bash

jobs:
  detect-versions:
    name: Detect distro versions
    runs-on: ubuntu-latest
    outputs:
      ubuntu_stable: ${{ steps.detect.outputs.ubuntu_stable }}
      ubuntu_lts: ${{ steps.detect.outputs.ubuntu_lts }}
      debian_stable: ${{ steps.detect.outputs.debian_stable }}
      debian_oldstable: ${{ steps.detect.outputs.debian_oldstable }}
      fedora_release: ${{ steps.detect.outputs.fedora_release }}
      rocky_release: ${{ steps.detect.outputs.rocky_release }}
      rocky_previous: ${{ steps.detect.outputs.rocky_previous }}
      rocky_latest: ${{ steps.detect.outputs.rocky_latest }}
      rocky_container_previous: ${{ steps.detect.outputs.rocky_container_previous }}
      rocky_container_latest: ${{ steps.detect.outputs.rocky_container_latest }}
      rocky_releases: ${{ steps.detect.outputs.rocky_releases }}
      opensuse_leap: ${{ steps.detect.outputs.opensuse_leap }}
      suse_bci: ${{ steps.detect.outputs.suse_bci }}
    steps:
      - name: Fetch latest Ubuntu/Debian versions
        id: detect
        run: |
          set -euo pipefail
          python - <<'PY'
          import os
          import urllib.request
          import json
          import re

          def fetch_text(url):
              with urllib.request.urlopen(url, timeout=10) as resp:
                  return resp.read().decode()

          def latest_ubuntu_non_lts():
              try:
                  data = fetch_text("https://changelogs.ubuntu.com/meta-release")
                  versions = []
                  block = {}
                  for line in data.splitlines() + [""]:
                      if not line.strip():
                          if block.get("Supported") == "1" and block.get("Lts", "0") == "0" and "Version" in block:
                              versions.append(block["Version"])
                          block = {}
                          continue
                      if ":" in line:
                          k, v = line.split(":", 1)
                          block[k.strip()] = v.strip()
                  if versions:
                      return versions[-1]
              except Exception:
                  pass
              return "latest"

          def latest_ubuntu_lts():
              try:
                  data = fetch_text("https://changelogs.ubuntu.com/meta-release-lts")
                  versions = []
                  block = {}
                  for line in data.splitlines() + [""]:
                      if not line.strip():
                          if block.get("Supported") == "1" and block.get("Lts") == "1" and "Version" in block:
                              versions.append(block["Version"])
                          block = {}
                          continue
                      if ":" in line:
                          k, v = line.split(":", 1)
                          block[k.strip()] = v.strip()
                  if versions:
                      return versions[-1]
              except Exception:
                  pass
              return "22.04"

          def debian_codename(track):
              url = f"https://deb.debian.org/debian/dists/{track}/Release"
              try:
                  data = fetch_text(url)
                  for line in data.splitlines():
                      if line.startswith("Codename:"):
                          return line.split(":", 1)[1].strip()
              except Exception:
                  pass
              return track

          def latest_fedora_release():
              try:
                  data = fetch_text("https://getfedora.org/releases.json")
                  releases = json.loads(data)
                  versions = []
                  for entry in releases.get("fedora", []):
                      ver = entry.get("version")
                      status = entry.get("status")
                      edition = entry.get("edition")
                      if edition == "Everything" and status == "Active" and ver is not None:
                          versions.append(int(ver))
                  if versions:
                      return str(max(versions))
              except Exception:
                  pass
              return "39"

          def rocky_mirrors():
              try:
                  listing = fetch_text("https://mirrors.rockylinux.org/mirrorlist?path=/pub/rocky")
                  return [
                      line.strip().rstrip("/") + "/"
                      for line in listing.splitlines()
                      if line.strip() and not line.startswith("#")
                  ]
              except Exception:
                  return []

          def rocky_version_list():
              # metadata.json disappeared from download.rockylinux.org; walk mirrors instead.
              def extract_versions(html):
                  found = []
                  for line in html.splitlines():
                      match = re.search(r'href="([0-9]+(?:\.[0-9]+)?)/"', line)
                      if match:
                          found.append(match.group(1))
                  return found

              all_versions = []
              for mirror in rocky_mirrors():
                  try:
                      versions = extract_versions(fetch_text(mirror))
                      if versions:
                          all_versions.extend(versions)
                  except Exception:
                      continue

              # Fall back to the legacy path if mirrors fail completely.
              try:
                  data = fetch_text("https://download.rockylinux.org/pub/rocky/metadata.json")
                  meta = json.loads(data)
                  versions = []
                  for rel in meta.get("releases", []):
                      if rel.get("released") is True and rel.get("version"):
                          versions.append(rel.get("version"))
                  if versions:
                      all_versions.extend(versions)
              except Exception:
                  pass
              return sorted(set(all_versions), key=lambda v: [int(x) for x in v.split(".")])

          def rocky_container_tags(majors, count=2):
              try:
                  data = fetch_text("https://hub.docker.com/v2/repositories/library/rockylinux/tags?page_size=100")
                  tags = {t.get("name") for t in json.loads(data).get("results", []) if t.get("name")}
              except Exception:
                  tags = set()

              chosen = []
              for rel in reversed(majors):
                  candidates = [rel, f"{rel}.0", f"{rel}.1"]
                  for cand in candidates:
                      if cand in tags and cand not in chosen:
                          chosen.append(cand)
                          break
                  if len(chosen) >= count:
                      break

              if len(chosen) < count and tags:
                  numeric_tags = [t for t in tags if t and t[0].isdigit()]
                  for tag in sorted(numeric_tags, key=lambda v: [int(x) for x in re.findall(r"\d+", v) or [0]], reverse=True):
                      if tag not in chosen:
                          chosen.append(tag)
                      if len(chosen) >= count:
                          break

              if not chosen:
                  chosen.append("9")
              while len(chosen) < count:
                  chosen.append(chosen[-1])

              return chosen[:count]

          def latest_rocky_releases(count=2):
              versions_sorted = rocky_version_list()
              if not versions_sorted:
                  return ["9"][:count]
              majors = sorted({v.split(".")[0] for v in versions_sorted}, key=int)
              trimmed = majors[-count:]
              return trimmed or [versions_sorted[-1].split(".")[0]]

          def latest_opensuse_leap():
              import re
              try:
                  data = fetch_text("https://download.opensuse.org/distribution/leap/")
                  versions = []
                  for line in data.splitlines():
                      match = re.search(r'href=\"([0-9]+(?:\\.[0-9]+)?)/\"', line)
                      if match:
                          versions.append(match.group(1))
                  if versions:
                      versions_sorted = sorted(versions, key=lambda v: [int(x) for x in v.split(".")])
                      return versions_sorted[-1]
              except Exception:
                  pass
              return "15.6"

          def latest_suse_bci():
              try:
                  data = fetch_text("https://registry.suse.com/v2/bci/bci-base/tags/list")
                  tags = json.loads(data).get("tags", [])
                  versions = []
                  for t in tags:
                      if all(ch.isdigit() or ch == "." for ch in t):
                          versions.append(t)
                  if versions:
                      versions_sorted = sorted(versions, key=lambda v: [int(x) for x in v.split(".")])
                      return versions_sorted[-1]
              except Exception:
                  pass
              return "15.6"

          ubuntu_stable = latest_ubuntu_non_lts()
          ubuntu_lts = latest_ubuntu_lts()
          debian_stable = debian_codename("stable")
          debian_oldstable = debian_codename("oldstable")
          fedora_release = latest_fedora_release()
          rocky_releases = latest_rocky_releases()
          rocky_latest = rocky_releases[-1]
          rocky_previous = rocky_releases[-2] if len(rocky_releases) > 1 else rocky_releases[-1]
          rocky_container_latest, rocky_container_previous = rocky_container_tags(rocky_releases, count=2)
          rocky_release = rocky_latest
          opensuse_leap = latest_opensuse_leap()
          suse_bci = latest_suse_bci()

          with open(os.environ["GITHUB_OUTPUT"], "a", encoding="utf-8") as fh:
              fh.write(f"ubuntu_stable={ubuntu_stable}\n")
              fh.write(f"ubuntu_lts={ubuntu_lts}\n")
              fh.write(f"debian_stable={debian_stable}\n")
              fh.write(f"debian_oldstable={debian_oldstable}\n")
              fh.write(f"fedora_release={fedora_release}\n")
              fh.write(f"rocky_release={rocky_release}\n")
              fh.write(f"rocky_previous={rocky_previous}\n")
              fh.write(f"rocky_latest={rocky_latest}\n")
              fh.write(f"rocky_container_latest={rocky_container_latest}\n")
              fh.write(f"rocky_container_previous={rocky_container_previous}\n")
              fh.write(f"rocky_releases={json.dumps(rocky_releases)}\n")
              fh.write(f"opensuse_leap={opensuse_leap}\n")
              fh.write(f"suse_bci={suse_bci}\n")
          PY

  build-deb-ubuntu-stable:
    name: Build Debian Packages (Ubuntu Stable)
    runs-on: ubuntu-latest
    needs:
      - detect-versions
    container: ubuntu:${{ needs.detect-versions.outputs.ubuntu_stable }}
    defaults:
      run:
        shell: bash
    steps:
      - name: Prepare build environment
        run: |
          set -euo pipefail
          apt-get update
          apt-get install -y \
            git ca-certificates \
            build-essential devscripts debhelper \
            cdbs dh-autoreconf autotools-dev \
            autoconf automake libtool pkg-config \
            gettext libev-dev libpcre2-dev \
            libc-ares-dev libssl-dev libbsd-dev fakeroot dpkg-dev

      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ github.event_name == 'workflow_dispatch' && inputs.ref || github.ref }}

      - name: Build Debian packages
        run: |
          set -euo pipefail
          dpkg-buildpackage -us -uc -b -j"$(nproc)"

      - name: Collect Debian artifacts
        run: |
          set -euo pipefail
          mkdir -p artifacts/deb/ubuntu-stable
          shopt -s nullglob
          for pkg in ../*.deb; do
            base=$(basename "$pkg")
            name=${base%%_*}
            ver_arch=${base#*_}
            arch=${ver_arch##*_}
            ver=${ver_arch%_*}
            cp "$pkg" "artifacts/deb/ubuntu-stable/${name}_${ver}~ubuntu-${{ needs.detect-versions.outputs.ubuntu_stable }}_${arch}.deb"
          done

      - name: Upload Debian artifacts
        uses: actions/upload-artifact@v4
        with:
          name: deb-packages-ubuntu-stable
          path: artifacts/deb/ubuntu-stable/
          if-no-files-found: error

  build-deb-ubuntu-lts:
    name: Build Debian Packages (Ubuntu LTS)
    runs-on: ubuntu-latest
    needs:
      - detect-versions
    container: ubuntu:${{ needs.detect-versions.outputs.ubuntu_lts }}
    defaults:
      run:
        shell: bash
    steps:
      - name: Prepare build environment
        run: |
          set -euo pipefail
          apt-get update
          apt-get install -y \
            git ca-certificates \
            build-essential devscripts debhelper \
            cdbs dh-autoreconf autotools-dev \
            autoconf automake libtool pkg-config \
            gettext libev-dev libpcre2-dev \
            libc-ares-dev libssl-dev libbsd-dev fakeroot dpkg-dev

      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ github.event_name == 'workflow_dispatch' && inputs.ref || github.ref }}

      - name: Build Debian packages
        run: |
          set -euo pipefail
          dpkg-buildpackage -us -uc -b -j"$(nproc)"

      - name: Collect Debian artifacts
        run: |
          set -euo pipefail
          mkdir -p artifacts/deb/ubuntu-lts
          shopt -s nullglob
          for pkg in ../*.deb; do
            base=$(basename "$pkg")
            name=${base%%_*}
            ver_arch=${base#*_}
            arch=${ver_arch##*_}
            ver=${ver_arch%_*}
            cp "$pkg" "artifacts/deb/ubuntu-lts/${name}_${ver}~ubuntu-${{ needs.detect-versions.outputs.ubuntu_lts }}_${arch}.deb"
          done

      - name: Upload Debian artifacts
        uses: actions/upload-artifact@v4
        with:
          name: deb-packages-ubuntu-lts
          path: artifacts/deb/ubuntu-lts/
          if-no-files-found: error

  build-deb-debian-stable:
    name: Build Debian Packages (Debian Stable)
    runs-on: ubuntu-latest
    needs:
      - detect-versions
    container: debian:${{ needs.detect-versions.outputs.debian_stable }}
    defaults:
      run:
        shell: bash
    steps:
      - name: Prepare build environment
        run: |
          set -euo pipefail
          apt-get update
          apt-get install -y \
            git ca-certificates \
            build-essential devscripts debhelper \
            cdbs dh-autoreconf autotools-dev \
            autoconf automake libtool pkg-config \
            gettext libev-dev libpcre2-dev \
            libc-ares-dev libssl-dev libbsd-dev fakeroot dpkg-dev

      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ github.event_name == 'workflow_dispatch' && inputs.ref || github.ref }}

      - name: Build Debian packages
        run: |
          set -euo pipefail
          dpkg-buildpackage -us -uc -b -j"$(nproc)"

      - name: Collect Debian artifacts
        run: |
          set -euo pipefail
          mkdir -p artifacts/deb/debian-stable
          shopt -s nullglob
          for pkg in ../*.deb; do
            base=$(basename "$pkg")
            name=${base%%_*}
            ver_arch=${base#*_}
            arch=${ver_arch##*_}
            ver=${ver_arch%_*}
            cp "$pkg" "artifacts/deb/debian-stable/${name}_${ver}~debian-${{ needs.detect-versions.outputs.debian_stable }}_${arch}.deb"
          done

      - name: Upload Debian artifacts
        uses: actions/upload-artifact@v4
        with:
          name: deb-packages-debian-stable
          path: artifacts/deb/debian-stable/
          if-no-files-found: error

  build-deb-debian-lts:
    name: Build Debian Packages (Debian LTS)
    runs-on: ubuntu-latest
    needs:
      - detect-versions
    container: debian:${{ needs.detect-versions.outputs.debian_oldstable }}
    defaults:
      run:
        shell: bash
    steps:
      - name: Prepare build environment
        run: |
          set -euo pipefail
          apt-get update
          apt-get install -y \
            git ca-certificates \
            build-essential devscripts debhelper \
            cdbs dh-autoreconf autotools-dev \
            autoconf automake libtool pkg-config \
            gettext libev-dev libpcre2-dev \
            libc-ares-dev libssl-dev libbsd-dev fakeroot dpkg-dev

      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ github.event_name == 'workflow_dispatch' && inputs.ref || github.ref }}

      - name: Build Debian packages
        run: |
          set -euo pipefail
          dpkg-buildpackage -us -uc -b -j"$(nproc)"

      - name: Collect Debian artifacts
        run: |
          set -euo pipefail
          mkdir -p artifacts/deb/debian-lts
          shopt -s nullglob
          for pkg in ../*.deb; do
            base=$(basename "$pkg")
            name=${base%%_*}
            ver_arch=${base#*_}
            arch=${ver_arch##*_}
            ver=${ver_arch%_*}
            cp "$pkg" "artifacts/deb/debian-lts/${name}_${ver}~debian-${{ needs.detect-versions.outputs.debian_oldstable }}_${arch}.deb"
          done

      - name: Upload Debian artifacts
        uses: actions/upload-artifact@v4
        with:
          name: deb-packages-debian-lts
          path: artifacts/deb/debian-lts/
          if-no-files-found: error

  build-rpm-fedora:
    name: Build RPM Packages (Fedora)
    runs-on: ubuntu-latest
    needs:
      - detect-versions
    defaults:
      run:
        shell: bash
    container:
      image: fedora:${{ needs.detect-versions.outputs.fedora_release }}
    steps:
      - name: Install required tooling
        run: |
          set -euo pipefail
          dnf install -y \
            git rpm-build make gcc gcc-c++ \
            autoconf automake libtool pkgconfig \
            gettext-devel libev-devel pcre2-devel \
            c-ares-devel openssl-devel libbsd-devel systemd-rpm-macros autoconf-archive \
            which tar

      - name: Mark workspace as safe for git
        run: git config --global --add safe.directory "$GITHUB_WORKSPACE"

      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ github.event_name == 'workflow_dispatch' && inputs.ref || github.ref }}
      - name: Allow git in container path
        run: git config --global --add safe.directory "$GITHUB_WORKSPACE"

      - name: Prepare source tarball
        run: |
          set -euo pipefail
          ver="${{ needs.detect-versions.outputs.suse_bci }}"
          if command -v SUSEConnect >/dev/null 2>&1; then
            SUSEConnect -p "sle-module-development-tools/${ver}/x86_64" || true
            SUSEConnect -p "PackageHub/${ver}/x86_64" || true
          fi
          zypper -n install --recommends --type pattern devel_basis || true
          ./autogen.sh
          ./configure
          make dist
          DIST_TARBALL=$(ls -1t sniproxy-*.tar.gz | head -n1)
          TAR_VERSION=${DIST_TARBALL#sniproxy-}
          TAR_VERSION=${TAR_VERSION%.tar.gz}
          RPM_TOPDIR="${RPMBUILD_TOPDIR:-$(rpm --eval '%{_topdir}')}"
          rm -rf "${RPM_TOPDIR}"
          mkdir -p "${RPM_TOPDIR}"/{BUILD,BUILDROOT,RPMS,SOURCES,SPECS,SRPMS}
          cp "${DIST_TARBALL}" "${RPM_TOPDIR}/SOURCES/"
          sed "s/^Version:.*/Version: ${TAR_VERSION}/" redhat/sniproxy.spec > "${RPM_TOPDIR}/SPECS/sniproxy.spec"
          printf 'RPM_TOPDIR=%s\n' "$RPM_TOPDIR" >> "$GITHUB_ENV"

      - name: Build RPM packages
        run: |
          set -euo pipefail
          RPM_TOPDIR="${RPMBUILD_TOPDIR:-/tmp/rpmbuild}"
          if ! rpmbuild --define "_topdir ${RPM_TOPDIR}" -ba "${RPM_TOPDIR}/SPECS/sniproxy.spec"; then
            echo "rpmbuild failed, dumping config.log files:" >&2
            find "${RPM_TOPDIR}/BUILD" -name config.log -print -exec cat {} \; || true
            exit 1
          fi

      - name: Collect RPM artifacts
        run: |
          set -euo pipefail
          RPM_TOPDIR="${RPMBUILD_TOPDIR:-/tmp/rpmbuild}"
          mkdir -p artifacts/rpm/fedora-${{ needs.detect-versions.outputs.fedora_release }}
          find "${RPM_TOPDIR}/RPMS" -name '*.rpm' -print | while read -r pkg; do
            base=$(basename "$pkg")
            namever=${base%%.rpm}
            cp "$pkg" "artifacts/rpm/fedora-${{ needs.detect-versions.outputs.fedora_release }}/${namever}.fedora.${{ needs.detect-versions.outputs.fedora_release }}.rpm"
          done

      - name: Upload RPM artifacts
        uses: actions/upload-artifact@v4
        with:
          name: rpm-packages-fedora-${{ needs.detect-versions.outputs.fedora_release }}
          path: artifacts/rpm/fedora-${{ needs.detect-versions.outputs.fedora_release }}/
          if-no-files-found: error

  build-rpm-rocky:
    name: Build RPM Packages (Rocky ${{ needs.detect-versions.outputs.rocky_latest }})
    runs-on: ubuntu-latest
    needs:
      - detect-versions
    defaults:
      run:
        shell: bash
    container:
      image: rockylinux:${{ needs.detect-versions.outputs.rocky_container_latest }}
    steps:
      - name: Install required tooling
        run: |
          set -euo pipefail
          pkgmgr=""
          if command -v dnf >/dev/null 2>&1; then
            pkgmgr="dnf"
          elif command -v microdnf >/dev/null 2>&1; then
            microdnf install -y dnf dnf-plugins-core
            pkgmgr="dnf"
          fi
          if [ -z "$pkgmgr" ]; then
            echo "No supported package manager (dnf/microdnf) found" >&2
            exit 1
          fi
          $pkgmgr install -y dnf-plugins-core epel-release
          dnf config-manager --set-enabled crb || true
          $pkgmgr install -y \
            git rpm-build make gcc gcc-c++ \
            autoconf automake libtool pkgconfig \
            gettext-devel libev-devel pcre2-devel \
            c-ares-devel openssl-devel libbsd-devel systemd-rpm-macros autoconf-archive \
            which tar

      - name: Mark workspace as safe for git
        run: git config --global --add safe.directory "$GITHUB_WORKSPACE"

      - name: Upgrade autoconf to 2.71 if needed
        run: |
          set -euo pipefail
          ver=$(autoconf --version | head -n1 | awk '{print $NF}')
          need="2.71"
          if [ "$(printf '%s\n' "$need" "$ver" | sort -V | head -n1)" != "$need" ]; then
            curl -fsSL -o /tmp/autoconf.tar.gz https://ftp.gnu.org/gnu/autoconf/autoconf-2.71.tar.gz
            tar -C /tmp -xf /tmp/autoconf.tar.gz
            cd /tmp/autoconf-2.71
            ./configure --prefix=/usr/local
            make -j"$(nproc)"
            make install
          fi

      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ github.event_name == 'workflow_dispatch' && inputs.ref || github.ref }}

      - name: Prepare source tarball
        run: |
          set -euo pipefail
          ver="${{ needs.detect-versions.outputs.opensuse_leap }}"
          if command -v SUSEConnect >/dev/null 2>&1; then
            SUSEConnect -p "sle-module-development-tools/${ver}/x86_64" || true
            SUSEConnect -p "PackageHub/${ver}/x86_64" || true
          fi
          ./autogen.sh
          ./configure
          make dist
          DIST_TARBALL=$(ls -1t sniproxy-*.tar.gz | head -n1)
          TAR_VERSION=${DIST_TARBALL#sniproxy-}
          TAR_VERSION=${TAR_VERSION%.tar.gz}
          RPM_TOPDIR="${RPMBUILD_TOPDIR:-$(rpm --eval '%{_topdir}')}"
          rm -rf "${RPM_TOPDIR}"
          mkdir -p "${RPM_TOPDIR}"/{BUILD,BUILDROOT,RPMS,SOURCES,SPECS,SRPMS}
          cp "${DIST_TARBALL}" "${RPM_TOPDIR}/SOURCES/"
          sed "s/^Version:.*/Version: ${TAR_VERSION}/" redhat/sniproxy.spec > "${RPM_TOPDIR}/SPECS/sniproxy.spec"
          printf 'RPM_TOPDIR=%s\n' "$RPM_TOPDIR" >> "$GITHUB_ENV"

      - name: Build RPM packages
        run: |
          set -euo pipefail
          RPM_TOPDIR="${RPMBUILD_TOPDIR:-/tmp/rpmbuild}"
          if ! rpmbuild --define "_topdir ${RPM_TOPDIR}" -ba "${RPM_TOPDIR}/SPECS/sniproxy.spec"; then
            echo "rpmbuild failed, dumping config.log files:" >&2
            find "${RPM_TOPDIR}/BUILD" -name config.log -print -exec cat {} \; || true
            exit 1
          fi

      - name: Collect RPM artifacts
        run: |
          set -euo pipefail
          RPM_TOPDIR="${RPMBUILD_TOPDIR:-/tmp/rpmbuild}"
          mkdir -p artifacts/rpm/rocky-${{ needs.detect-versions.outputs.rocky_latest }}
          find "${RPM_TOPDIR}/RPMS" -name '*.rpm' -print | while read -r pkg; do
            base=$(basename "$pkg")
            namever=${base%%.rpm}
            cp "$pkg" "artifacts/rpm/rocky-${{ needs.detect-versions.outputs.rocky_latest }}/${namever}.rocky.${{ needs.detect-versions.outputs.rocky_latest }}.rpm"
          done

      - name: Upload RPM artifacts
        uses: actions/upload-artifact@v4
        with:
          name: rpm-packages-rocky-${{ needs.detect-versions.outputs.rocky_latest }}
          path: artifacts/rpm/rocky-${{ needs.detect-versions.outputs.rocky_latest }}/
          if-no-files-found: error

  build-rpm-rocky-previous:
    name: Build RPM Packages (Rocky ${{ needs.detect-versions.outputs.rocky_previous }})
    runs-on: ubuntu-latest
    needs:
      - detect-versions
    defaults:
      run:
        shell: bash
    container:
      image: rockylinux:${{ needs.detect-versions.outputs.rocky_container_previous }}
    steps:
      - name: Install required tooling
        run: |
          set -euo pipefail
          pkgmgr=""
          if command -v dnf >/dev/null 2>&1; then
            pkgmgr="dnf"
          elif command -v microdnf >/dev/null 2>&1; then
            microdnf install -y dnf dnf-plugins-core
            pkgmgr="dnf"
          fi
          if [ -z "$pkgmgr" ]; then
            echo "No supported package manager (dnf/microdnf) found" >&2
            exit 1
          fi
          $pkgmgr install -y dnf-plugins-core epel-release
          dnf config-manager --set-enabled crb || true
          $pkgmgr install -y \
            git rpm-build make gcc gcc-c++ \
            autoconf automake libtool pkgconfig \
            gettext-devel libev-devel pcre2-devel \
            c-ares-devel openssl-devel libbsd-devel systemd-rpm-macros autoconf-archive \
            which tar

      - name: Mark workspace as safe for git
        run: git config --global --add safe.directory "$GITHUB_WORKSPACE"

      - name: Upgrade autoconf to 2.71 if needed
        run: |
          set -euo pipefail
          ver=$(autoconf --version | head -n1 | awk '{print $NF}')
          need="2.71"
          if [ "$(printf '%s\n' "$need" "$ver" | sort -V | head -n1)" != "$need" ]; then
            curl -fsSL -o /tmp/autoconf.tar.gz https://ftp.gnu.org/gnu/autoconf/autoconf-2.71.tar.gz
            tar -C /tmp -xf /tmp/autoconf.tar.gz
            cd /tmp/autoconf-2.71
            ./configure --prefix=/usr/local
            make -j"$(nproc)"
            make install
          fi

      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ github.event_name == 'workflow_dispatch' && inputs.ref || github.ref }}

      - name: Prepare source tarball
        run: |
          set -euo pipefail
          ver="${{ needs.detect-versions.outputs.opensuse_leap }}"
          if command -v SUSEConnect >/dev/null 2>&1; then
            SUSEConnect -p "sle-module-development-tools/${ver}/x86_64" || true
            SUSEConnect -p "PackageHub/${ver}/x86_64" || true
          fi
          ./autogen.sh
          ./configure
          make dist
          DIST_TARBALL=$(ls -1t sniproxy-*.tar.gz | head -n1)
          TAR_VERSION=${DIST_TARBALL#sniproxy-}
          TAR_VERSION=${TAR_VERSION%.tar.gz}
          RPM_TOPDIR="${RPMBUILD_TOPDIR:-$(rpm --eval '%{_topdir}')}"
          rm -rf "${RPM_TOPDIR}"
          mkdir -p "${RPM_TOPDIR}"/{BUILD,BUILDROOT,RPMS,SOURCES,SPECS,SRPMS}
          cp "${DIST_TARBALL}" "${RPM_TOPDIR}/SOURCES/"
          sed "s/^Version:.*/Version: ${TAR_VERSION}/" redhat/sniproxy.spec > "${RPM_TOPDIR}/SPECS/sniproxy.spec"
          printf 'RPM_TOPDIR=%s\n' "$RPM_TOPDIR" >> "$GITHUB_ENV"

      - name: Build RPM packages
        run: |
          set -euo pipefail
          RPM_TOPDIR="${RPMBUILD_TOPDIR:-/tmp/rpmbuild}"
          if ! rpmbuild --define "_topdir ${RPM_TOPDIR}" -ba "${RPM_TOPDIR}/SPECS/sniproxy.spec"; then
            echo "rpmbuild failed, dumping config.log files:" >&2
            find "${RPM_TOPDIR}/BUILD" -name config.log -print -exec cat {} \; || true
            exit 1
          fi

      - name: Collect RPM artifacts
        run: |
          set -euo pipefail
          RPM_TOPDIR="${RPMBUILD_TOPDIR:-/tmp/rpmbuild}"
          mkdir -p artifacts/rpm/rocky-${{ needs.detect-versions.outputs.rocky_previous }}
          find "${RPM_TOPDIR}/RPMS" -name '*.rpm' -print | while read -r pkg; do
            base=$(basename "$pkg")
            namever=${base%%.rpm}
            cp "$pkg" "artifacts/rpm/rocky-${{ needs.detect-versions.outputs.rocky_previous }}/${namever}.rocky.${{ needs.detect-versions.outputs.rocky_previous }}.rpm"
          done

      - name: Upload RPM artifacts
        uses: actions/upload-artifact@v4
        with:
          name: rpm-packages-rocky-${{ needs.detect-versions.outputs.rocky_previous }}
          path: artifacts/rpm/rocky-${{ needs.detect-versions.outputs.rocky_previous }}/
          if-no-files-found: error

  build-rpm-opensuse:
    name: Build RPM Packages (openSUSE Leap)
    runs-on: ubuntu-latest
    needs:
      - detect-versions
    defaults:
      run:
        shell: bash
    container:
      image: opensuse/leap:${{ needs.detect-versions.outputs.opensuse_leap }}
    steps:
      - name: Install required tooling
        run: |
          set -euo pipefail
          zypper -n ref
          zypper -n install \
            git rpm-build make gcc gcc-c++ \
            autoconf automake libtool pkg-config \
            gettext-tools libev-devel \
            c-ares-devel libopenssl-devel libbsd-devel systemd-rpm-macros \
            tar which
          if ! zypper -n install libpcre2-8-devel; then
            zypper -n install pcre2-devel || zypper -n install libpcre2-devel
          fi
      - name: Mark workspace as safe for git
        run: git config --global --add safe.directory "$GITHUB_WORKSPACE"

      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ github.event_name == 'workflow_dispatch' && inputs.ref || github.ref }}

      - name: Ensure autoconf 2.71+
        run: |
          set -euo pipefail
          ver=$(autoconf --version | head -n1 | awk '{print $NF}')
          need="2.71"
          if [ "$(printf '%s\n' "$need" "$ver" | sort -V | head -n1)" != "$need" ]; then
            zypper -n install --recommends --type pattern devel_basis || true
            curl -fsSL -o /tmp/autoconf.tar.gz https://mirrors.kernel.org/gnu/autoconf/autoconf-2.71.tar.gz || \
            curl -fsSL -o /tmp/autoconf.tar.gz https://ftp.gnu.org/gnu/autoconf/autoconf-2.71.tar.gz
            tar -C /tmp -xf /tmp/autoconf.tar.gz
            cd /tmp/autoconf-2.71
            ./configure --prefix=/usr/local
            make -j"$(nproc)"
            make install
          fi

      - name: Prepare source tarball
        run: |
          set -euo pipefail
          ./autogen.sh
          ./configure
          make dist
          DIST_TARBALL=$(ls -1t sniproxy-*.tar.gz | head -n1)
          TAR_VERSION=${DIST_TARBALL#sniproxy-}
          TAR_VERSION=${TAR_VERSION%.tar.gz}
          RPM_TOPDIR="${RPMBUILD_TOPDIR:-$(rpm --eval '%{_topdir}')}"
          rm -rf "${RPM_TOPDIR}"
          mkdir -p "${RPM_TOPDIR}"/{BUILD,BUILDROOT,RPMS,SOURCES,SPECS,SRPMS}
          cp "${DIST_TARBALL}" "${RPM_TOPDIR}/SOURCES/"
          sed "s/^Version:.*/Version: ${TAR_VERSION}/" redhat/sniproxy.spec > "${RPM_TOPDIR}/SPECS/sniproxy.spec"
          printf 'RPM_TOPDIR=%s\n' "$RPM_TOPDIR" >> "$GITHUB_ENV"

      - name: Build RPM packages
        run: |
          set -euo pipefail
          RPM_TOPDIR="${RPMBUILD_TOPDIR:-/tmp/rpmbuild}"
          if ! rpmbuild --define "_topdir ${RPM_TOPDIR}" -ba "${RPM_TOPDIR}/SPECS/sniproxy.spec"; then
            echo "rpmbuild failed, dumping config.log files:" >&2
            find "${RPM_TOPDIR}/BUILD" -name config.log -print -exec cat {} \; || true
            exit 1
          fi

      - name: Collect RPM artifacts
        run: |
          set -euo pipefail
          RPM_TOPDIR="${RPMBUILD_TOPDIR:-/tmp/rpmbuild}"
          mkdir -p artifacts/rpm/opensuse-${{ needs.detect-versions.outputs.opensuse_leap }}
          find "${RPM_TOPDIR}/RPMS" -name '*.rpm' -print | while read -r pkg; do
            base=$(basename "$pkg")
            namever=${base%%.rpm}
            cp "$pkg" "artifacts/rpm/opensuse-${{ needs.detect-versions.outputs.opensuse_leap }}/${namever}.opensuse.${{ needs.detect-versions.outputs.opensuse_leap }}.rpm"
          done

      - name: Upload RPM artifacts
        uses: actions/upload-artifact@v4
        with:
          name: rpm-packages-opensuse-${{ needs.detect-versions.outputs.opensuse_leap }}
          path: artifacts/rpm/opensuse-${{ needs.detect-versions.outputs.opensuse_leap }}/
          if-no-files-found: error

  build-rpm-suse:
    name: Build RPM Packages (SUSE BCI)
    runs-on: ubuntu-latest
    needs:
      - detect-versions
    defaults:
      run:
        shell: bash
    container:
      image: registry.suse.com/bci/bci-base:${{ needs.detect-versions.outputs.suse_bci }}
    steps:
      - name: Install required tooling
        run: |
          set -euo pipefail
          ver="${{ needs.detect-versions.outputs.suse_bci }}"
          if command -v SUSEConnect >/dev/null 2>&1; then
            SUSEConnect -p "sle-module-development-tools/${ver}/x86_64" || true
            SUSEConnect -p "PackageHub/${ver}/x86_64" || true
          fi
          zypper -n ref
          zypper -n install \
            git rpm-build make gcc gcc-c++ \
            autoconf automake libtool pkg-config \
            gettext-tools libev-devel \
            c-ares-devel libopenssl-devel libbsd-devel systemd-rpm-macros \
            tar which curl
          if ! zypper -n install libpcre2-8-devel; then
            zypper -n install pcre2-devel || zypper -n install libpcre2-devel
          fi
      - name: Mark workspace as safe for git
        run: git config --global --add safe.directory "$GITHUB_WORKSPACE"

      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ github.event_name == 'workflow_dispatch' && inputs.ref || github.ref }}

      - name: Ensure autoconf 2.71+
        run: |
          set -euo pipefail
          zypper -n install --recommends --type pattern devel_basis || true
          ver=$(autoconf --version | head -n1 | awk '{print $NF}')
          need="2.71"
          if [ "$(printf '%s\n' "$need" "$ver" | sort -V | head -n1)" != "$need" ]; then
            curl -fsSL -o /tmp/autoconf.tar.gz https://mirrors.kernel.org/gnu/autoconf/autoconf-2.71.tar.gz || \
            curl -fsSL -o /tmp/autoconf.tar.gz https://ftp.gnu.org/gnu/autoconf/autoconf-2.71.tar.gz
            tar -C /tmp -xf /tmp/autoconf.tar.gz
            cd /tmp/autoconf-2.71
            ./configure --prefix=/usr/local
            make -j"$(nproc)"
            make install
          fi

      - name: Prepare source tarball
        run: |
          set -euo pipefail
          ./autogen.sh
          ./configure
          make dist
          DIST_TARBALL=$(ls -1t sniproxy-*.tar.gz | head -n1)
          TAR_VERSION=${DIST_TARBALL#sniproxy-}
          TAR_VERSION=${TAR_VERSION%.tar.gz}
          RPM_TOPDIR="${RPMBUILD_TOPDIR:-$(rpm --eval '%{_topdir}')}"
          rm -rf "${RPM_TOPDIR}"
          mkdir -p "${RPM_TOPDIR}"/{BUILD,BUILDROOT,RPMS,SOURCES,SPECS,SRPMS}
          cp "${DIST_TARBALL}" "${RPM_TOPDIR}/SOURCES/"
          sed "s/^Version:.*/Version: ${TAR_VERSION}/" redhat/sniproxy.spec > "${RPM_TOPDIR}/SPECS/sniproxy.spec"
          printf 'RPM_TOPDIR=%s\n' "$RPM_TOPDIR" >> "$GITHUB_ENV"

      - name: Build RPM packages
        run: |
          set -euo pipefail
          RPM_TOPDIR="${RPMBUILD_TOPDIR:-/tmp/rpmbuild}"
          if ! rpmbuild --define "_topdir ${RPM_TOPDIR}" -ba "${RPM_TOPDIR}/SPECS/sniproxy.spec"; then
            echo "rpmbuild failed, dumping config.log files:" >&2
            find "${RPM_TOPDIR}/BUILD" -name config.log -print -exec cat {} \; || true
            exit 1
          fi

      - name: Collect RPM artifacts
        run: |
          set -euo pipefail
          RPM_TOPDIR="${RPMBUILD_TOPDIR:-/tmp/rpmbuild}"
          mkdir -p artifacts/rpm/suse-${{ needs.detect-versions.outputs.suse_bci }}
          find "${RPM_TOPDIR}/RPMS" -name '*.rpm' -print | while read -r pkg; do
            base=$(basename "$pkg")
            namever=${base%%.rpm}
            cp "$pkg" "artifacts/rpm/suse-${{ needs.detect-versions.outputs.suse_bci }}/${namever}.suse.${{ needs.detect-versions.outputs.suse_bci }}.rpm"
          done

      - name: Upload RPM artifacts
        uses: actions/upload-artifact@v4
        with:
          name: rpm-packages-suse-${{ needs.detect-versions.outputs.suse_bci }}
          path: artifacts/rpm/suse-${{ needs.detect-versions.outputs.suse_bci }}/
          if-no-files-found: error

  publish:
    name: Upload Release Assets
    runs-on: ubuntu-latest
    needs:
      - detect-versions
      - build-deb-ubuntu-stable
      - build-deb-ubuntu-lts
      - build-deb-debian-stable
      - build-deb-debian-lts
      - build-rpm-fedora
      - build-rpm-rocky
      - build-rpm-rocky-previous
      - build-rpm-opensuse
      - build-rpm-suse
    steps:
      - name: Download Debian artifacts
        uses: actions/download-artifact@v4
        with:
          pattern: deb-packages-*
          path: release-assets/deb
          merge-multiple: true

      - name: Download RPM artifacts
        uses: actions/download-artifact@v4
        with:
          pattern: rpm-packages-*
          path: release-assets/rpm
          merge-multiple: true

      - name: Upload release assets
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ github.event_name == 'workflow_dispatch' && inputs.release_tag || github.event.release.tag_name }}
          files: |
            release-assets/deb/*.deb
            release-assets/rpm/*.rpm
