.TH SNIPROXY.CONF 5 "06 Feb 2026" "SNIProxy manual" "sniproxy"

.SH NAME

sniproxy.conf - sniproxy configuration file

.SH SYNOPSIS

/etc/sniproxy.conf

.SH DESCRIPTION

/etc/sniproxy.conf is the configuration file for sniproxy.
Statements are separated by either a new line or semi-colon.
Lines starting with \&# are comments.
The configuration is broken down into stanzas delimited by
curly braces. Characters may be escaped using \&\\. Configuration
directives may be shortened as long as they are unambiguous e.g. user
daemon instead of username daemon.

.SS USERNAME

.PP
.nf
username daemon
.fi
.PP

Specify the user sniproxy will run as.
When sniproxy is launched as super user,
it will drop permissions to this user.

.SS GROUPNAME

.PP
.nf
groupname _sniproxy
.fi
.PP

Specify the group sniproxy will run as after dropping privileges. Either
the full \fBgroupname\fR directive or the short \fBgroup\fR form may be
used.

.SS PIDFILE

.PP
.nf
pidfile /var/run/sniproxy.pid
.fi
.PP

Specify the path to the pid file, the directory must be writeable by the
user sniproxy runs as.

.SS MAX_CONNECTIONS

.PP
.nf
max_connections 20000
.fi
.PP

Limit the maximum number of simultaneously active connections accepted
across all listeners. Once this threshold is reached new connections are
closed immediately until existing ones complete. The default value of 0
lets sniproxy derive a ceiling from the configured RLIMIT_NOFILE value
while holding roughly 20% of available descriptors in reserve for
listeners, DNS sockets, and internal bookkeeping.

.SS PER_IP_CONNECTION_RATE

.PP
.nf
per_ip_connection_rate 20
.fi
.PP

Limit how many new client connections a single source IP address may open
per second. The value is interpreted as connections per second and is
applied globally across all listeners using a token-bucket policy that
allows short bursts up to the configured rate. The default is 30
connections per second. Set the value to 0 to disable per-IP rate
limiting entirely.

.SS CONNECTION_BUFFER_LIMIT

.PP
.nf
connection_buffer_limit 4M
.fi
.PP

Cap the amount of buffered data a single connection may hold on either
side. The value applies to both the client and server buffers, accepts
optional K, M, or G suffixes (powers of 1024), and must fall between
8 KiB and 1 GiB. The default is 1 MiB per side. Tighter caps protect the
proxy from slow clients pinning unbounded RAM.

.SS CLIENT_BUFFER_LIMIT

.PP
.nf
client_buffer_limit 8M
.fi
.PP

Override the client-side buffer cap independently using the same syntax
and range as \fBconnection_buffer_limit\fR. The most recent directive for
each side wins, so a configuration may set a shared limit and then
override only one direction.

.SS SERVER_BUFFER_LIMIT

.PP
.nf
server_buffer_limit 8M
.fi
.PP

Override the server-side buffer cap independently. This is useful for
backends that return large responses relative to request size. Limits are
applied to new connections immediately and propagated to existing
connections during a configuration reload.

.SS MAINLOOP

.PP
.nf
io_collect_interval 0.0005
timeout_collect_interval 0.005
.fi
.PP

Tune how libev batches readiness notifications. \fBio_collect_interval\fR delays the next poll by up to the specified number of seconds so that multiple sockets can become ready before the kernel is queried again. \fBtimeout_collect_interval\fR performs the same batching for timers. Small non-zero values reduce system call pressure and improve throughput on busy instances at the cost of a few hundred microseconds of additional latency. Set either value to 0 to disable batching.

.SS ERROR_LOG

.PP
.nf
error_log {
    syslog daemon
    priority notice
}
.fi
.PP

Specify how error messages should be handled. Messages can be either
logged to syslog using the syslog directive, which sends logs to a
given syslog facility. Alternatively the filename directive may be
specified to log to file, and these two options are mutually
exclusive. The priority directive indicates what severity of
messages should be logged. Accepted priorities are the standard
syslog priorities, in increasing verbosity: emergency, alert,
critical, error, warning, notice, info, and debug.

.SS ACCESS_LOG

.PP
.nf
access_log {
    filename /var/log/sniproxy/access.log
}
.fi
.PP

Specify how connections should be logged, and this may be overridden in
a specific listener. Connections are logged after both the client and
server sockets have been closed. The syslog and priority directive may
be used here as in error_log.

.SS RESOLVER

.PP
.nf
resolver {
    nameserver 127.0.0.1
    mode ipv6_first
}
.fi
.PP

Specify how DNS queries should be resolved, which is only required if
using hostnames as addresses in the configuration or using wildcard
backends. If not specified the IPv4 only queries will be performed using
the system default name servers.

Multiple \fBnameserver\fR directives may be supplied. Optional
\fBsearch\fR directives append the given domain to hostnames that do not
already end with a trailing dot before resolution.

Nameservers may point at DNS-over-TLS upstreams using the
\fBdot://ADDRESS/SNI[/tls1.2|tls1.3]\fR form. ADDRESS can be an IP literal
or hostname; when using an IP literal you must also supply a TLS hostname or
the literal \fIinsecure\fR segment to disable verification. TLS 1.2 is the
default minimum; append \fI/tls1.3\fR to require TLS 1.3 on builds that support
it. On OpenSSL without TLS 1.3, \fI/tls1.3\fR is ignored with a warning and
TLS 1.2 is enforced.

Four modes are supported:

ipv4_only: query for any A records, use the first A record returned
(following CNAME records).

ipv6_only: query for any AAAA records, use the first AAAA record
returned (following CNAME records).

ipv4_first: query for both A and AAAA records, wait for both queries to
complete, use the first A record if any, otherwise use the first AAAA
record.

ipv6_first: query for both A and AAAA records, wait for both queries to
complete, use the first AAAA record if any, otherwise use the first A
record.

The optional \fBmax_concurrent_queries\fR directive limits how many DNS lookups
may be in flight at once (default 256). Lower values cap resolver resource
usage, while higher values increase throughput for configurations that rely on
wildcard or hostname targets.

Set \fBdnssec_validation\fR to one of 'off', 'relaxed', or 'strict'. The
default is relaxed, which requests DNSSEC data but falls back to unsigned
answers when your resolver cannot authenticate the response. The strict mode
requires the AD flag, so unsigned zones fail to resolve and a c-ares build
with DNSSEC/Trust AD support is mandatory. Use 'off' to disable DNSSEC
entirely if your upstream resolvers do not support it.

It is strongly recommended to use a local name server, since a single
socket is reused for all DNS queries and thus the UDP port number is
predictable, leaving the query only protected from spoofed replies
by the 16 bit query ID. Additionally, since no internal DNS caching
is performed, a local resolver can improve performance.

.SS LISTENER

.PP
.nf
listener 192.0.2.10:80 {
    protocol http
    reuseport yes
    table http_hosts
    fallback 192.0.2.100:80
    bad_requests log
    source 192.0.2.10

    access_log {
        filename /var/log/sniproxy/http_access.log
    }
}

listener [::]:80 {
    protocol http
    ipv6_v6only yes
    table http_hosts

    fallback unix:/var/run/http_fallback_unix.sock
}
.fi
.PP

Define a listening address to accept new connections from clients on.
Addresses may be specified as an IPv4 literal followed by a TCP port
number, an IPv6 literal followed by a TCP port number, a bare TCP port
number, or a unix socket path prefixed with 'unix:'.

Protocol defines how the client request should be parsed to obtain the
requested hostname. Two protocols are supported: http and tls.

Reuseport directive controls if the port is opened in SO_REUSEPORT mode,
which allows one to run several sniproxy instances on the same
ip:port pair. This enables evenly load-balancing incoming connections
between these instances without the use of any external
load-balancing proxy. Requires Linux kernel 3.9+. Setting reuseport
to "yes" enables this functionality.

The ipv6_v6only directive controls whether listening on the IPv6 any
address '::' will accept connections to any IPv4 address as well as an
IPv6 address. This is useful if the user wants different configurations
for IPv4 and IPv6 or wishes to handle IPv4 traffic with another
server/proxy entirely. This directive applies only to IPv6 listeners
and is ignored on other listeners.

Table specifies the name of the table used to look up which server
to forward the connection to based on the hostname extracted from
the initial client request. If no table directive is specified the
default, unnamed, table will be used.

The fallback directive specifies a server to be used if the client
request cannot be parsed, a server cannot be found in the table for the
hostname, or the hostname cannot be resolved. This should be an IP
address and port or a unix socket path. When using TLS listeners the
fallback still terminates the client TLS handshake and forwards the
traffic unmodified to the configured destination. Issuing a second
\fBfallback\fR directive with the literal argument \fBproxy\fR after the
address instructs sniproxy to prepend an HAProxy PROXY protocol v1 header
whenever the fallback path is taken, allowing the backend to recover the
original client IP and port.

The bad_requests directive allows logging the contents of the client
request if it is not parsable. This is useful for debugging.

The source directive allows specifying an address to bind to before
connecting to the backend server. In most cases it is better to omit
this option and allow the operating system to select the outgoing
address automatically. Do not include a port number in this address,
because doing so will limit the proxy to one simultaneous connection to
each server at a time. The special argument \fBclient\fR enables
transparent proxy mode (IP_TRANSPARENT) where supported, preserving the
original source address when connecting to the backend. This mode
requires root privileges and an operating system that implements
transparent sockets (such as Linux).

An optional acl block restricts which clients may connect to a listener
based on CIDR ranges. The directive takes a default policy of either
allow_except (the default, accept every client except those listed) or
deny_except (deny every client except the listed ranges):

.nf
    acl deny_except {
        10.0.0.0/8
        2001:db8::/32
    }
.fi

When an acl block is omitted every client is accepted. Multiple
statements may be provided in a block. IPv4 and IPv6 ranges may be mixed
freely, and IPv4-mapped IPv6 addresses are matched against IPv4 ranges.
The policy choice is global: mixing allow_except and deny_except blocks
anywhere in the configuration causes sniproxy to exit with a configuration
error.

The access log configuration may be overridden on each listener.

.SS TABLE

.PP
.nf
table http_hosts {
    ^example\\.com$ 192.0.2.101
    ^example\\.net$ 192.0.2.102
    ^example\\.org$ 192.0.2.103 proxy_protocol
}
.fi
.PP

Tables define how to map each hostname to a backend server. Each
request's hostname is matched against entries in the table in order
until a match is found and that server is used. The server address may
be either an IP, an IP and port, a unix socket path, a hostname, or '*'.
If no port is specified, the port of the listener that received the
connection will be used.

The optional proxy_protocol option will prepend a HAProxy PROXY v1
protocol header to the proxied connection, allowing supporting
webservers to obtain the source and destination IP and port of the
original incoming TCP connection.


.SH "SEE ALSO"
.PP
\fBsniproxy\fR(8)
